################################################################################################################################################################################################################################################################
##                                                                                                                                                                                                                                                            ##
##                                                                                                    Beginning of selfcal pipeline                                                                                                                           ##
##                                                                                                                                                                                                                                                            ##
################################################################################################################################################################################################################################################################

### Steps to run
pipeline.steps = [listsplit,listsplit2,listtemp2,listFRtar,listtec,addcol,sky_tar,sourcedbtar,listsourcedbtar2,predicttar,parmdbFRtar,fixFRtar,smoothtar,teccal,makevdstar,findvds,globaldbtec,h5parmtec,losototec,applytec,image_high1,createmap_high_image,mask_high,image_high2,listmodel,filter_model,make_sourcedb_target,listsourcedbtar3,predicttar_high,subtract_model,image_low,createmap_low_image,listmodel_low,mask_low,filter_model_low,make_sourcedb_target_low,listsourcedbtar4,predicttar_low,corrupt_model,subtract_model_low,restore_model]

################################################################################################################################################################################################################################################################
################################################################################################################################################################################################################################################################

### Step: 00a
### --- Map splitted files
listsplit.control.kind                                       =   plugin                     # plugin -> short, non-parallel step
listsplit.control.type                                       =   createMapfile              # generate a new mapfile
listsplit.control.method                                     =   mapfile_from_folder        # look for all files in a given directory
listsplit.control.folder                                     =   {{ job_directory }}        # directory in which to look for the data
listsplit.control.mapfile_dir                                =   input.output.mapfile_dir   # put the mapfile into the runtime directory
listsplit.control.filename                                   =   listsplit.mapfile          # name of the generated mapfile
listsplit.control.pattern                                    =   *.time_split-split         # use only files that match this pattern

### Step: 00b
### --- Map splitted files all to one
listsplit2.control.kind                                      =   plugin
listsplit2.control.type                                      =   createMapfile
listsplit2.control.method                                    =   mapfile_all_to_one
listsplit2.control.mapfile_dir                               =   input.output.mapfile_dir
listsplit2.control.filename                                  =   listsplit2.mapfile
listsplit2.control.mapfile_in                                =   listsplit.output.mapfile

### Step: 00c
### --- List of the single target MS which is used as a template for making a skymodel
listtemp2.control.kind                                       =   plugin                     # plugin -> short, non-parallel step
listtemp2.control.type                                       =   createMapfile              # generate a new mapfile
listtemp2.control.method                                     =   mapfile_from_folder        # look for all files in a given directory
listtemp2.control.folder                                     =   {{ target_directory }}     # directory in which to look for the data
listtemp2.control.mapfile_dir                                =   input.output.mapfile_dir   # put the mapfile into the runtime directory
listtemp2.control.filename                                   =   listtemp2.mapfile           # name of the generated mapfile
listtemp2.control.pattern                                    =   {{ target_template }}      # use only files that match this pattern

### Step: 00d
### --- Update mapfile for calibrator FR tables
listFRtar.control.kind                                       =   plugin
listFRtar.control.type                                       =   changeMapfile
listFRtar.control.mapfile_in                                 =   listsplit.output.mapfile
listFRtar.control.join_files                                 =   instrument-fr
listFRtar.control.newname                                    =   listFRtar.mapfile

### Step: 00e
### --- Update mapfile for calibrator FR tables
listtec.control.kind                                         =   plugin
listtec.control.type                                         =   changeMapfile
listtec.control.mapfile_in                                   =   listsplit.output.mapfile
listtec.control.join_files                                   =   instrument-tec
listtec.control.newname                                      =   listtec.mapfile

### Step: 01
### --- Adding MODEL columns
addcol.control.type                                          =   executable_args
addcol.control.max_per_node                                  =   {{ max_per_node_limit }}
addcol.control.executable                                    =   {{ scripts }}/addcol2ms.py
addcol.argument.flags                                        =   [-m,listsplit.output.mapfile,outputkey,-c,MODEL_DATA_HIGHRES;SUBTRACTED_DATA]

### Step: 02
# Download the TGSS ADR skymodel for the target
sky_tar.control.type                                         =   pythonplugin  
sky_tar.control.executable                                   =   {{ scripts }}/download_tgss_skymodel_target.py
sky_tar.argument.flags                                       =   [listtemp2.output.mapfile]
sky_tar.argument.DoDownload                                  =   True
sky_tar.argument.SkymodelPath                                =   {{ job_directory }}/{{ target }}.skymodel
sky_tar.argument.Radius                                      =   5.                                                                #in degrees

### Step: 03a
### --- Create skymodel for target
sourcedbtar.control.type                                     =   setupsourcedb
sourcedbtar.control.cmdline.mapfile                          =   listtemp2.output.mapfile
sourcedbtar.control.skymodel                                 =   {{ job_directory }}/{{ target }}.skymodel

### Step: 03b
### --- Expand skymodel mapfile to the amount of target files
listsourcedbtar2.control.kind                                =   plugin
listsourcedbtar2.control.type                                =   expandMapfile
listsourcedbtar2.control.mapfile_in                          =   sourcedbtar.output.mapfile
listsourcedbtar2.control.mapfile_ref                         =   listsplit.output.mapfile
listsourcedbtar2.control.mapfile_dir                         =   input.output.mapfile_dir
listsourcedbtar2.control.filename                            =   listsourcedbtar.mapfile

### Step: 04
### --- Add target model to MODEL_DATA
predicttar.control.type                                      =   dppp
predicttar.control.inplace                                   =   True
predicttar.control.max_per_node                              =   {{ max_per_node_limit }}
predicttar.control.error_tolerance                           =   {{ error_tolerance }}
predicttar.argument.numthreads                               =   {{ max_dppp_threads }}
predicttar.argument.msin                                     =   listsplit.output.mapfile
predicttar.argument.msin.baseline                            =   [CR]S*&
predicttar.argument.msin.datacolumn                          =   DATA
predicttar.argument.msout.datacolumn                         =   MODEL_DATA
predicttar.argument.steps                                    =   [predict]
predicttar.argument.predict.type                             =   predict
predicttar.argument.predict.sourcedb                         =   listsourcedbtar2.output.mapfile
predicttar.argument.predict.usebeammodel                     =   True
predicttar.argument.predict.usechannelfreq                   =   True
predicttar.argument.predict.beammode                         =   array_factor

### Step: 05
### --- Creation of fake-parmdbs (Faraday Rotation)
parmdbFRtar.control.type                                     =   python-calibrate-stand-alone
parmdbFRtar.control.error_tolerance                          =   {{ error_tolerance }}
parmdbFRtar.argument.force                                   =   True                                       # force replaceing of parmDB and skyDB
parmdbFRtar.argument.observation                             =   listsplit.output.mapfile                     # run on files generated by flag_compress step
parmdbFRtar.argument.parmdb-name                             =   instrument-fr
parmdbFRtar.argument.catalog                                 =   {{ skymodels }}/{{ calibrator }}.skymodel  # which skymodel to use
parmdbFRtar.argument.numthreads                              =   {{ max_per_node }}
parmdbFRtar.argument.Strategy.ChunkSize                      =   30
parmdbFRtar.argument.Strategy.Steps                          =   [solve]
parmdbFRtar.argument.Step.solve.Operation                    =   SOLVE
parmdbFRtar.argument.Step.solve.Model.Sources                =   [@MODEL_DATA]
parmdbFRtar.argument.Step.solve.Model.Cache.Enable           =   T
parmdbFRtar.argument.Step.solve.Model.FaradayRotation.Enable =   T
parmdbFRtar.argument.Step.solve.Solve.Parms                  =   ["RotationMeasure:*"]
parmdbFRtar.argument.Step.solve.Solve.CellSize.Freq          =   0
parmdbFRtar.argument.Step.solve.Solve.CellSize.Time          =   30
parmdbFRtar.argument.Step.solve.Solve.CellChunkSize          =   30
parmdbFRtar.argument.Step.solve.Solve.PropagateSolutions     =   F
parmdbFRtar.argument.Step.solve.Solve.Options.MaxIter        =   1

### Step: 06
### --- Fix entries in the NAMES subtable
fixFRtar.control.type                                        =   executable_args
fixFRtar.control.executable                                  =   {{ scripts }}/fixFR-self.bash
fixFRtar.control.error_tolerance                             =   {{ error_tolerance }}
fixFRtar.argument.flags                                      =   [listFRtar.output.mapfile]

### Step: 07
### --- Smooth the data (baseline-based)
smoothtar.control.type                                       =   executable_args
smoothtar.control.error_tolerance                            =   {{ error_tolerance }}
smoothtar.control.executable                                 =   {{ scripts }}/BLsmooth.py
smoothtar.argument.flags                                     =   [-r,-f,0.2,-i,DATA,-o,SMOOTHED_DATA,listsplit.output.mapfile]

### Step: 08
### --- Calibrate smoothed data
teccal.control.type                                          =   dppp
teccal.control.inplace                                       =   True
teccal.control.error_tolerance                               =   {{ error_tolerance }}
teccal.control.mapfiles_in                                   =   [listsplit.output.mapfile,listtec.output.mapfile]
teccal.control.inputkeys                                     =   [infiles,parmdbs]
teccal.argument.numthreads                                   =   {{ max_dppp_threads }}
teccal.argument.msin                                         =   infiles
teccal.argument.msin.datacolumn                              =   SMOOTHED_DATA
teccal.argument.msin.baseline                                =   [CR]S*&
teccal.argument.msout.datacolumn                             =   CORRECTED_DATA
teccal.argument.steps                                        =   [filter,gaincal]
teccal.argument.filter.blrange                               =   [1500,1e30]
teccal.argument.gaincal.type                                 =   gaincal
teccal.argument.gaincal.parmdb                               =   parmdbs
teccal.argument.gaincal.caltype                              =   tecandphase
teccal.argument.gaincal.maxiter                              =   500
teccal.argument.gaincal.nchan                                =   1
teccal.argument.gaincal.solint                               =   1
teccal.argument.gaincal.propagatesolutions                   =   False
teccal.argument.gaincal.usemodelcolumn                       =   True

### Step: 09a
### --- Creating VDS files
makevdstar.control.type                                      =   vdsmaker
makevdstar.control.cmdline.inmap                             =   listsplit.output.mapfile
makevdstar.control.unlink                                    =   True

### Step: 09b
### --- Creating mapfile for the VDS files
findvds.control.kind                                         =   plugin
findvds.control.type                                         =   createMapfile
findvds.control.method                                       =   mapfile_from_folder
findvds.control.folder                                       =   {{ job_directory }}/vds
findvds.control.mapfile_dir                                  =   input.output.mapfile_dir
findvds.control.filename                                     =   findvds.mapfile

### Step: 09c
### --- Create globaldb out of the VDS files for the instrument tables
globaldbtec.control.type                                     =   executable_args
globaldbtec.control.executable                               =   {{ losoto_directory }}/bin/parmdb_collector.py
globaldbtec.argument.flags                                   =   [-v,-d,findvds.output.mapfile,-p,instrument-tec,-g,outputkey]

### Step: 09d
### --- Import globaldb to h5parm
h5parmtec.control.type                                       =   executable_args
h5parmtec.control.executable                                 =   {{ losoto_directory }}/bin/H5parm_importer.py
h5parmtec.argument.flags                                     =   [-v,outputkey,globaldbtec.output.mapfile]

### Step: 09c
### --- Running losoto to plot, flag and do the Farady Rotation extraction
losototec.control.type                                       =   executable_args
losototec.control.executable                                 =   {{ losoto_directory }}/bin/losoto
losototec.control.parsetasfile                               =   True
losototec.control.args_format                                =   losoto
losototec.argument.flags                                     =   [-v,h5parmtec.output.mapfile]
losototec.argument.LoSoTo.Steps                              =   [plotTEC, plotCSP, plotCSPTEC]
losototec.argument.LoSoTo.Solset                             =   [sol000]
losototec.argument.LoSoTo.Soltab                             =   []
losototec.argument.LoSoTo.SolType                            =   []
losototec.argument.LoSoTo.ant                                =   []
losototec.argument.LoSoTo.pol                                =   [XX, YY]
losototec.argument.LoSoTo.dir                                =   []
losototec.argument.LoSoTo.Ncpu                               =   {{ max_per_node }}
losototec.argument.LoSoTo.Steps.plotCSPTEC.Operation         =   PLOT
losototec.argument.LoSoTo.Steps.plotCSPTEC.Soltab            =   [sol000/scalarphase000]
losototec.argument.LoSoTo.Steps.plotCSPTEC.Axes              =   time
losototec.argument.LoSoTo.Steps.plotCSPTEC.TableAxis         =   ant
losototec.argument.LoSoTo.Steps.plotCSPTEC.PlotFlag          =   True
losototec.argument.LoSoTo.Steps.plotCSPTEC.Prefix            =   plots-tec/csptec_
losototec.argument.LoSoTo.Steps.plotCSPTEC.Reference         =   'CS001LBA'
losototec.argument.LoSoTo.Steps.plotCSPTEC.Add               =   [sol000/tec000]
losototec.argument.LoSoTo.Steps.plotCSP.Operation            =   PLOT
losototec.argument.LoSoTo.Steps.plotCSP.Soltab               =   [sol000/scalarphase000]
losototec.argument.LoSoTo.Steps.plotCSP.Axes                 =   time
losototec.argument.LoSoTo.Steps.plotCSP.TableAxis            =   ant
losototec.argument.LoSoTo.Steps.plotCSP.PlotFlag             =   True
losototec.argument.LoSoTo.Steps.plotCSP.Prefix               =   plots-tec/csp_
losototec.argument.LoSoTo.Steps.plotCSP.Reference            =   'CS001LBA'
losototec.argument.LoSoTo.Steps.plotTEC.Operation            =   PLOT
losototec.argument.LoSoTo.Steps.plotTEC.Soltab               =   [sol000/tec000]
losototec.argument.LoSoTo.Steps.plotTEC.Axes                 =   time
losototec.argument.LoSoTo.Steps.plotTEC.TableAxis            =   ant
losototec.argument.LoSoTo.Steps.plotTEC.PlotFlag             =   True
losototec.argument.LoSoTo.Steps.plotTEC.MinMax               =   [-0.5,0.5]
losototec.argument.LoSoTo.Steps.plotTEC.Prefix               =   plots-tec/tec_
losototec.argument.LoSoTo.Steps.plotTEC.Reference            =  'CS001LBA'

### Step: 10
### --- Apply TEC and common scalar phase 
applytec.control.type                                        =   dppp
applytec.control.inplace                                     =   True
applytec.control.error_tolerance                             =   {{ error_tolerance }}
applytec.control.max_per_node                                =   {{ max_per_node_limit }}
applytec.control.mapfiles_in                                 =   [listsplit.output.mapfile,listtec.output.mapfile]
applytec.control.inputkeys                                   =   [infiles,parmdbs]
applytec.argument.numthreads                                 =   {{ max_dppp_threads }}
applytec.argument.msin                                       =   infiles
applytec.argument.msin.datacolumn                            =   DATA
applytec.argument.msout.datacolumn                           =   CORRECTED_DATA
applytec.argument.steps                                      =   [correcttec,correctphase]
applytec.argument.correcttec.type                            =   applycal
applytec.argument.correcttec.parmdb                          =   parmdbs
applytec.argument.correcttec.correction                      =   tec
applytec.argument.correctphase.type                          =   applycal
applytec.argument.correctphase.parmdb                        =   parmdbs
applytec.argument.correctphase.correction                    =   commonscalarphase

### Step: 11
# First high-res imaging
image_high1.control.kind                                     =   recipe
image_high1.control.type                                     =   executable_args
image_high1.control.executable                               =   {{ wsclean_directory }}/bin/wsclean
image_high1.control.outputsuffixes                           =   [-image.fits,-model.fits]
image_high1.control.outputkey                                =   name
image_high1.control.args_format                              =   wsclean
image_high1.control.max_per_node                             =   1
image_high1.control.error_tolerance                          =   {{ error_tolerance }}
image_high1.control.mapfiles_in                              =   [listsplit2.output.mapfile]
image_high1.control.inputkeys                                =   [infiles]
image_high1.argument.flags                                   =   [-reorder,-no-update-model-required,-joinchannels,infiles]
image_high1.argument.size                                    =   3000 3000
image_high1.argument.trim                                    =   2500 2500
image_high1.argument.mem                                     =   {{ max_mem_per_img }}
image_high1.argument.j                                       =   {{ max_per_node }}
image_high1.argument.baseline-averaging                      =   2.0
image_high1.argument.scale                                   =   12arcsec
image_high1.argument.weight                                  =   briggs 0.0
image_high1.argument.niter                                   =   100000
image_high1.argument.maxuv-l                                 =   5000
image_high1.argument.mgain                                   =   0.9
image_high1.argument.pol                                     =   I
image_high1.argument.fit-spectral-pol                        =   2
image_high1.argument.channelsout                             =   10
image_high1.argument.auto-threshold                          =   20
image_high1.argument.minuv-l                                 =   100

### Step: 12a
# create a map with the wsclean MFS image only
createmap_high_image.control.kind                            =   plugin
createmap_high_image.control.type                            =   createMapfile
createmap_high_image.control.method                          =   mapfile_from_folder
createmap_high_image.control.mapfile_dir                     =   input.output.mapfile_dir
createmap_high_image.control.filename                        =   createmap_high_image.mapfile
createmap_high_image.control.folder                          =   {{ job_directory }}
createmap_high_image.control.pattern                         =   *high1*MFS-image.fits

### Step: 12b
# make mask for the high-res image
mask_high.control.type                                       =   pythonplugin
mask_high.control.executable                                 =   {{ scripts }}/make_clean_mask.py
mask_high.control.max_per_node                               =   1
mask_high.control.error_tolerance                            =   {{ error_tolerance }}
mask_high.control.mapfile_in                                 =   createmap_high_image.output.mapfile
mask_high.control.inputkey                                   =   imagefile
mask_high.control.outputkey                                  =   maskfile
mask_high.argument.flags                                     =   [imagefile,maskfile]
mask_high.argument.threshisl                                 =   3.0
mask_high.argument.threshpix                                 =   7.0
mask_high.argument.atrous_do                                 =   True
mask_high.argument.rmsbox                                    =   (55,12)
mask_high.argument.rmsbox_bright                             =   (30,10)
mask_high.argument.adaptive_rmsbox                           =   True
mask_high.argument.img_format                                =   fits
mask_high.argument.atrous_jmax                               =   3

### Step: 13
# First high-res imaging
image_high2.control.kind                                     =   recipe
image_high2.control.type                                     =   executable_args
image_high2.control.executable                               =   {{ wsclean_directory }}/bin/wsclean
image_high2.control.outputsuffixes                           =   [-image.fits,-model.fits]
image_high2.control.outputkey                                =   name
image_high2.control.args_format                              =   wsclean
image_high2.control.max_per_node                             =   1
image_high2.control.error_tolerance                          =   {{ error_tolerance }}
image_high2.control.mapfiles_in                              =   [listsplit2.output.mapfile,mask_high.output.mapfile]
image_high2.control.inputkeys                                =   [infiles,mask]
image_high2.argument.flags                                   =   [-reorder,-no-update-model-required,-joinchannels,-save-source-list,infiles]
image_high2.argument.fitsmask                                =   mask
image_high2.argument.size                                    =   3000 3000
image_high2.argument.trim                                    =   2500 2500
image_high2.argument.mem                                     =   {{ max_mem_per_img }}
image_high2.argument.j                                       =   {{ max_per_node }}
image_high2.argument.baseline-averaging                      =   2.0
image_high2.argument.scale                                   =   12arcsec
image_high2.argument.weight                                  =   briggs 0.0
image_high2.argument.niter                                   =   100000
image_high2.argument.maxuv-l                                 =   5000
image_high2.argument.mgain                                   =   0.8
image_high2.argument.pol                                     =   I
image_high2.argument.fit-spectral-pol                        =   2
image_high2.argument.channelsout                             =   10
image_high2.argument.auto-threshold                          =   0.1
image_high2.argument.minuv-l                                 =   100

### Step: 14a
# create a map with the wsclean MFS image model only
listmodel.control.kind                                       =   plugin
listmodel.control.type                                       =   createMapfile              # generate a new mapfile
listmodel.control.method                                     =   mapfile_from_folder        # look for all files in a given directory
listmodel.control.folder                                     =   {{ job_directory }}        # directory in which to look for the data
listmodel.control.mapfile_dir                                =   input.output.mapfile_dir   # put the mapfile into the runtime directory
listmodel.control.filename                                   =   listmodel.mapfile
listmodel.control.pattern                                    =   *image_high2-sources.txt

### Step: 14b
# filter CC model
filter_model.control.type                                    =   pythonplugin
filter_model.control.executable                              =   {{ scripts }}/filter_model.py
filter_model.control.error_tolerance                         =   {{ error_tolerance }}
filter_model.control.mapfiles_in                             =   [listtemp2.output.mapfile,listmodel.output.mapfile,mask_high.output.mapfile]
filter_model.control.inputkeys                               =   [msfiles,inmodel,inmask]#,mask_high.output.mapfile,createmap_high_model.output.mapfile]
filter_model.argument.ms                                     =   msfiles
filter_model.argument.skymodel                               =   inmodel
filter_model.argument.maskname                               =   inmask
filter_model.argument.skymodel_cut                           =   outputkey
filter_model.argument.scripts                                =   {{ scripts }}

### Step: 15a
### --- Create skymodel for calibrator
make_sourcedb_target.control.kind                            =   recipe
make_sourcedb_target.control.type                            =   executable_args
make_sourcedb_target.control.executable                      =   {{ lofar_directory }}/bin/makesourcedb
make_sourcedb_target.control.error_tolerance                 =   {{ error_tolerance }}
make_sourcedb_target.control.args_format                     =   lofar
make_sourcedb_target.control.outputkey                       =   out
make_sourcedb_target.control.mapfile_in                      =   filter_model.output.mapfile
make_sourcedb_target.control.inputkey                        =   in
make_sourcedb_target.argument.format                         =   <
make_sourcedb_target.argument.outtype                        =   blob

### Step: 15b
### --- Expand skymodel mapfile to the amount of target files
listsourcedbtar3.control.kind                                =   plugin
listsourcedbtar3.control.type                                =   expandMapfile
listsourcedbtar3.control.mapfile_in                          =   make_sourcedb_target.output.mapfile
listsourcedbtar3.control.mapfile_ref                         =   listsplit.output.mapfile
listsourcedbtar3.control.mapfile_dir                         =   input.output.mapfile_dir
listsourcedbtar3.control.filename                            =   listsourcedbtar3.mapfile

### Step: 16
### --- Add selfcal-target model to MODEL_DATA
predicttar_high.control.type                                 =   dppp
predicttar_high.control.inplace                              =   True
predicttar_high.control.max_per_node                         =   {{ max_per_node_limit }}
predicttar_high.control.error_tolerance                      =   {{ error_tolerance }}
predicttar_high.argument.numthreads                          =   {{ max_dppp_threads }}
predicttar_high.argument.msin                                =   listsplit.output.mapfile
predicttar_high.argument.msin.baseline                       =   [CR]S*&
predicttar_high.argument.msin.datacolumn                     =   DATA
predicttar_high.argument.msout.datacolumn                    =   MODEL_DATA_HIGHRES
predicttar_high.argument.steps                               =   [predict]
predicttar_high.argument.predict.type                        =   predict
predicttar_high.argument.predict.sourcedb                    =   listsourcedbtar3.output.mapfile
predicttar_high.argument.predict.usebeammodel                =   False
predicttar_high.argument.predict.usechannelfreq              =   True
predicttar_high.argument.predict.beammode                    =   array_factor

### Step: 17
### --- Subtract model from all TCs
subtract_model.control.type                                  =   executable_args
subtract_model.control.executable                            =   {{ scripts }}/subtract.bash
subtract_model.control.error_tolerance                       =   {{ error_tolerance }}
subtract_model.argument.flags                                =   [listsplit.output.mapfile]

### Step: 18
# First low-res imaging
image_low.control.kind                                       =   recipe
image_low.control.type                                       =   executable_args
image_low.control.executable                                 =   {{ wsclean_directory }}/bin/wsclean
image_low.control.outputsuffixes                             =   [-image.fits,-model.fits]
image_low.control.outputkey                                  =   name
image_low.control.args_format                                =   wsclean
image_low.control.max_per_node                               =   1
image_low.control.error_tolerance                            =   {{ error_tolerance }}
image_low.control.mapfiles_in                                =   [listsplit2.output.mapfile]
image_low.control.inputkeys                                  =   [infiles]
image_low.argument.flags                                     =   [-reorder,-no-update-model-required,-joinchannels,-save-source-list,infiles]
image_low.argument.size                                      =   4500 4500
image_low.argument.trim                                      =   4000 4000
image_low.argument.mem                                       =   {{ max_mem_per_img }}
image_low.argument.j                                         =   {{ max_per_node }}
image_low.argument.baseline-averaging                        =   2.0
image_low.argument.scale                                     =   20arcsec
image_low.argument.weight                                    =   briggs 0.0
image_low.argument.niter                                     =   100000
image_low.argument.maxuv-l                                   =   2000
image_low.argument.mgain                                     =   0.8
image_low.argument.pol                                       =   I
image_low.argument.fit-spectral-pol                          =   2
image_low.argument.channelsout                               =   10
image_low.argument.auto-threshold                            =   1
image_low.argument.minuv-l                                   =   100

### Step: 19a
# create a map with the wsclean MFS image only
createmap_low_image.control.kind                             =   plugin
createmap_low_image.control.type                             =   createMapfile
createmap_low_image.control.method                           =   mapfile_from_folder
createmap_low_image.control.mapfile_dir                      =   input.output.mapfile_dir
createmap_low_image.control.filename                         =   createmap_low_image.mapfile
createmap_low_image.control.folder                           =   {{ job_directory }}
createmap_low_image.control.pattern                          =   *low*MFS-image.fits

### Step: 19b
# create a map with the wsclean MFS image model only
listmodel_low.control.kind                                   =   plugin
listmodel_low.control.type                                   =   createMapfile              # generate a new mapfile
listmodel_low.control.method                                 =   mapfile_from_folder        # look for all files in a given directory
listmodel_low.control.folder                                 =   {{ job_directory }}        # directory in which to look for the data
listmodel_low.control.mapfile_dir                            =   input.output.mapfile_dir   # put the mapfile into the runtime directory
listmodel_low.control.filename                               =   listmodel_low.mapfile
listmodel_low.control.pattern                                =   *image_low-sources.txt

### Step: 19c
# make mask for the low-res image
mask_low.control.type                                        =   pythonplugin
mask_low.control.executable                                  =   {{ scripts }}/make_clean_mask.py
mask_low.control.max_per_node                                =   1
mask_low.control.error_tolerance                             =   {{ error_tolerance }}
mask_low.control.mapfile_in                                  =   createmap_low_image.output.mapfile
mask_low.control.inputkey                                    =   imagefile
mask_low.control.outputkey                                   =   maskfile
mask_low.argument.flags                                      =   [imagefile,maskfile]
mask_low.argument.threshisl                                  =   5.0
mask_low.argument.threshpix                                  =   7.0
mask_low.argument.atrous_do                                  =   True
mask_low.argument.rmsbox                                     =   (55,12)
mask_low.argument.rmsbox_bright                              =   (30,10)
mask_low.argument.adaptive_rmsbox                            =   True
mask_low.argument.img_format                                 =   fits
mask_low.argument.atrous_jmax                                =   3

### Step: 19d
# filter CC model
filter_model_low.control.type                                =   pythonplugin
filter_model_low.control.executable                          =   {{ scripts }}/filter_model.py
filter_model_low.control.max_per_node                        =   1
filter_model_low.control.error_tolerance                     =   {{ error_tolerance }}
filter_model_low.control.mapfiles_in                         =   [listtemp2.output.mapfile,listmodel_low.output.mapfile,mask_low.output.mapfile]
filter_model_low.control.inputkeys                           =   [msfiles,inmodel,inmask]#,mask_high.output.mapfile,createmap_high_model.output.mapfile]
filter_model_low.argument.ms                                 =   msfiles
filter_model_low.argument.skymodel                           =   inmodel
filter_model_low.argument.maskname                           =   inmask
filter_model_low.argument.skymodel_cut                       =   outputkey

### Step: 20a
### --- Create skymodel for calibrator
make_sourcedb_target_low.control.kind                        =   recipe
make_sourcedb_target_low.control.type                        =   executable_args
make_sourcedb_target_low.control.executable                  =   {{ lofar_directory }}/bin/makesourcedb
make_sourcedb_target_low.control.error_tolerance             =   {{ error_tolerance }}
make_sourcedb_target_low.control.args_format                 =   lofar
make_sourcedb_target_low.control.outputkey                   =   out
make_sourcedb_target_low.control.mapfile_in                  =   filter_model_low.output.mapfile
make_sourcedb_target_low.control.inputkey                    =   in
make_sourcedb_target_low.argument.format                     =   <
make_sourcedb_target_low.argument.outtype                    =   blob

### Step: 20b
### --- Expand skymodel mapfile to the amount of target files
listsourcedbtar4.control.kind                                =   plugin
listsourcedbtar4.control.type                                =   expandMapfile
listsourcedbtar4.control.mapfile_in                          =   make_sourcedb_target_low.output.mapfile
listsourcedbtar4.control.mapfile_ref                         =   listsplit.output.mapfile
listsourcedbtar4.control.mapfile_dir                         =   input.output.mapfile_dir
listsourcedbtar4.control.filename                            =   listsourcedbtar4.mapfile

### Step: 21
### --- Add selfcal-target model to MODEL_DATA
predicttar_low.control.type                                  =   dppp
predicttar_low.control.inplace                               =   True
predicttar_low.control.max_per_node                          =   {{ max_per_node_limit }}
predicttar_low.control.error_tolerance                       =   {{ error_tolerance }}
predicttar_low.argument.numthreads                           =   {{ max_dppp_threads }}
predicttar_low.argument.msin                                 =   listsplit.output.mapfile
predicttar_low.argument.msin.baseline                        =   [CR]S*&
predicttar_low.argument.msin.datacolumn                      =   DATA
predicttar_low.argument.msout.datacolumn                     =   MODEL_DATA
predicttar_low.argument.steps                                =   [predict]
predicttar_low.argument.predict.type                         =   predict
predicttar_low.argument.predict.sourcedb                     =   listsourcedbtar4.output.mapfile
predicttar_low.argument.predict.usebeammodel                 =   False
predicttar_low.argument.predict.usechannelfreq               =   True
predicttar_low.argument.predict.beammode                     =   array_factor

### Step: 22
### --- corrupt model with TEC and common scalar phase solutions
corrupt_model.control.type                                   =   dppp
corrupt_model.control.inplace                                =   True
corrupt_model.control.max_per_node                           =   {{ max_per_node_limit }}
corrupt_model.control.error_tolerance                        =   {{ error_tolerance }}
corrupt_model.control.mapfiles_in                            =   [listsplit.output.mapfile,listtec.output.mapfile]
corrupt_model.control.inputkeys                              =   [infiles,parmdbs]
corrupt_model.argument.numthreads                            =   {{ max_dppp_threads }}
corrupt_model.argument.msin                                  =   infiles
corrupt_model.argument.msin.datacolumn                       =   MODEL_DATA
corrupt_model.argument.msout.datacolumn                      =   MODEL_DATA
corrupt_model.argument.steps                                 =   [applytec,applyphase]
corrupt_model.argument.applytec.type                         =   applycal
corrupt_model.argument.applytec.parmdb                       =   parmdbs
corrupt_model.argument.applytec.correction                   =   tec
corrupt_model.argument.applytec.invert                       =   False
corrupt_model.argument.applyphase.type                       =   applycal
corrupt_model.argument.applyphase.parmdb                     =   parmdbs
corrupt_model.argument.applyphase.correction                 =   commonscalarphase
corrupt_model.argument.applyphase.invert                     =   False

### Step: 23
### --- Subtract low-res model
subtract_model_low.control.type                              =   executable_args
subtract_model_low.control.executable                        =   {{ scripts }}/subtract_low.bash
subtract_model_low.control.error_tolerance                   =   {{ error_tolerance }}
subtract_model_low.argument.flags                            =   [listsplit.output.mapfile]

### Step: 24
### --- Restore best model
restore_model.control.type                                   =   executable_args
restore_model.control.executable                             =   {{ scripts }}/restore.bash
restore_model.control.error_tolerance                        =   {{ error_tolerance }}
restore_model.argument.flags                                 =   [listsplit.output.mapfile]


################################################################################################################################################################################################################################################################
##                                                                                                                                                                                                                                                            ##
##                                                                                                    End of selfcal pipeline                                                                                                                                 ##
##                                                                                                                                                                                                                                                            ##
################################################################################################################################################################################################################################################################